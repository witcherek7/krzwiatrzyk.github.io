---
layout: post
title: Docker breakdown
date: 2019-09-13 8:00:00 +0100
description: What docker Image is and what instructions are used to build it.
img: 
fig-caption: # Add figcaption (optional)
tags: [Docker]
---

## Docker commands cheat sheet

+ `docker export`  - export container files into the specific path 
<br>
Example: <i>`docker export dfs1233dsf -o application.tar`</i>

+ `docker history IMAGE` - shows built layers and their size

+ `docker create IMAGE sleep 120` - creates and image that will shut down after 120 seconds

+ `docker run IMAGE -l dev=Chris` - creates container with label dev

+ `docker ps -a -f label=dev=Chris` - search containers for matching label

+ `docker inspect CONTAINER` - displays informations about container, including labelss

+ `docker run IMAGE --hostname="linux"` - creates container with custom hostname instead of hash

+ `docker run IMAGE --dns=8.8.8.8 --dns-search=ex1.com --dns-search=ex2.com` - creates container and overrides default resolv.conf file that is copied from the host OS

+ `docker run IMAGE --mac-address="xx:xx:xx:xx:xx:xx"` - sets MAC address for container

+ `docker run IMAGE -v local/folder:/container/folder:ro,z` - mounts volume from host to container with read-only permissions. If any of the mount points don't exist they will be created.
<br>
Uppercase Z indicates that bind mount content is private and unshared. Lowercase z indicates that bind mount content is shared amond multiple containers. 
<br>
To check: <i>`mount | grep data`</i>

+ `docker run IMAGE --read-only=true` - restrict container to save any file inside of it. It will be possible to save to one location if we will mount volume with permissions RW.

+ `docker run IMAGE --tmpfs /tmp:rw,noexec,nodev,nosuid,size=256M` - binds tmp folder that will be deleted after container stops

+ `docker container update` - allows to change resource quotas for running container
<br>
Example: `docker update --cpus"1.5" CONTAINER`

+ `docker info` - shows information about docker deamon

+ `docker run IMAGE --cpu-shares 512 --cpuset=0,1` - cpu params

+ `docker run IMAGE --memory 512m` - memory params, constrain to 512 of RAM and 512 MB of addtional swap space

+ `docker run IMAGE --memory=512m --memory-swap=768m` - setting swap separatily, setting `--memory-swap` to -1 will turn off swap withing a container

+ `docker events` - display docker deamon logs

+ `docker run --oom-kill-disable --om-score-adj` - disables Linux OOM killer which kills a process when requested RAM is higher than available quota

+ `docker pause/unpause` - pauses container without killing process

+ `docker stop` - sends SIGTERM signal and waiting for the container to exit gracefully

+ `docker prune` - removes all stopped containers, not used networks, dangling images, build cache

+ `docker prune -a` - removes also all unused images

+ `docker rm $(docker ps -a -a)` - example combination of commands

## Docker commands cheat sheet 2

+ `docker version` - client, server, API version

+ `docker info` - OS, Kernel version, number of containers and images

+ `docker volume` - list volumes stored in root directory, those are not volume bindings done in container creation

+ `docker volume create my-docker-volume` - creating volume in docker, useful when data needs to be shared beetwen containers

+ `docker volume inspect` - volume inspect

+ `docker run --mount source=my-docker-volume,target=/app` - mounting craeted volume

+ `docker logs CONTAINER` - show container output saved by docker

## Docker config file

Daemon.json file is the configuration file for the dockerd server. It can be found in the /etc/docker/ directory. After changing this file it is needed to restart docker.

## Auto-Restarting container

This feature deserves separate chapter.

The `--restart` argument can take four values:
+ no - never restarts
+ always- restart whenever it exits
+ on-failure - whenever exits with a nonzero exit code
+ unless-stopped - restarts always unless it is intentionally stopped with `docker stop`

Example: `docker run --restart=on-failure:3` - docker will try to restart 3 time before giving up



## What Docker Image is?

Docker Image is a basic construct of application. Docker images provide the basis for everything that you will ever deploy and run with Docker. 

## Dockerfile

To build an image a set of instructions are used that are called Dockerfile. Those are layered steps that docker execute one-by-one to create an deployable image.

## Dockerfile instructions

+ `FROM` is a statement importing an image. Building an application always start with import base images. They can be viewed on Docker Hub.
<br>
Example: <i>`FROM node:11.11.0`</i>

+ `LABEL` is used to add metadata via key and value pairs. Used for additional information about image
<br>
Example: <i>`LABEL "developer"="kwiatrzy"`</i>
<br>
<br>
To show image labels type `docker inspect` command.

+ `USER` can be used to change with which user processes should be run. By default Docker runs all processess as root.
<br>
Example:<i> `USER kwiatrzy`</i>

+ `ENV` instruction allows to set shell variable that can be used later in process of building image.
<br>
Example:<i> `ENV APPATH /data/app`</i>

+ `ADD` command copies files from local filesystem or a remote URL into the image.
<br>
Example:<i> `ADD ./app /app`</i>

+ `WORKDIR` changes working directory for the remaining build instruction. 
<br>
Example:<i> `WORKDIR /app`</i>

+ `CMD` defines the command that launches the process in the container.
<br>
Example: <i>`CMD ["python","run.py"]`</i>


## Dockerfile basic information

Dockerfile is built by set of instruction in specific order. This order has high impact on build times. Instructions that changes a lot should be placed at the bottom of the Dockerfile.

## Docker Intermediate containers

While building docker image we can encounter an error that could stop bulding an image. In that situation it is easy to troubleshoot because docker is building an intermediate container for every step in Dockerfile. We can get into that container and check why the heck it causing us an error. Great!

## Docker additive layers

Layers are additive. This means that during build process deleting files won't save any memory, image won't be lighter because layers have weight. Layers that added files will still contain them. 

The solution is to delete files in the layer that they are added/created.

Example: If some packages are built and temp files are stored in cache that has to emptied we can delete it in the same layer.

Docker allows us to use string/chain commands to execute them in one layer.

Example (Fedora): <i style="color:orange">RUN dnf install httpd -y && dnf clean install</i>


## Resources Quota

### CPU Shares

Docker assings the number 1024 to represent full CPU pool. If we want to apply 1/2 of computing power to container we would assign to it 512 shares. 

Constraining the CPU only impacts the application's priority for CPU time.


Example: 2 containers have 512 quota and 1 has 1024. If amount of time for each process in CPU is 100 microseconds then containers with 512 share will get 50 microseconds each time and the one with 1024 will run for 100 microseconds.

### CPU Simplified method

`--cpus=".25"` - command can set a floating-point number beetwen 0.01 and number of CPU cores.

### Memory

Default constraint for memory is a hard limit.
